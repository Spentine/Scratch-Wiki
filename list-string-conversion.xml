<title>List and String Conversion</title>

<! ------------------------------------------------ >

<h1> List to String </h1>

<p> These scripts use CSV format with "/" as the escape character. A comma is added to the end of the string to mark the end. </p>

<h2> Scripts </h2>

<p> Scripts 1 and 2 work in a similar manner. The scripts loop through each item on the list and for each item on the list it will escape each "/" and "," character. At the end of each item, a "," character is appended to mark the end of the item. </p>

<h3> Script 1 (3rd fastest) </h3>

<pre class="blocks">
define list to string
set [output v] to ()
set [a v] to ()
repeat (length of [list v])
change [a v] by (1)
set [b v] to (0)
repeat (length of (item (a) of [list v]))
change [b v] by (1)
if <[/"] contains (letter (b) of (item (a) of [list v]))?> then
set [output v] to (join (output) [/])
end
set [output v] to (join (output) (letter (b) of (item (a) of [list v])))
end
set [output v] to (join (output) [,])
</pre>

<h3> Script 2 (2nd fastest) </h3>

<pre class="blocks">
define list to string
set [a v] to (0)
set [output v] to ()
repeat (length of [list v])
change [a v] by (1)
set [b v] to (0)
repeat (length of (item (a) of [list v]))
change [b v] by (1)
set [output v] to (join (output) (join (letter <[/"] contains (letter (b) of (item (a) of [list v]))?> of [/]) (letter (b) of (item (a) of [list v]))))
end
set [output v] to (join (output) [,])
</pre>

<h3> Script 3 (fastest) </h3>
<h4> Important Note </h4>
<p> This code runs nearly 30% faster than the previous script, however, the size of the size of the strings produced are nearly twice as long. It is good for performance but terrible for memory.  </p>

<p> Rather than only escaping each "/" and "," character, it escapes every character, removing the need to check whether the character is either "/" or ",". </p>

<p> If the list: </p>

<pre>
["hello", "me,you", "one/two", "/,/"]
</pre>

<p> is encoded with script 3, the output will be: </p>

<pre>
"/h/e/l/l/o,/m/e/,/y/o/u,/o/n/e///t/w/o,///,//,"
</pre>

<pre class="blocks">
define list to string
set [a v] to (0)
set [output v] to ()
repeat (length of [list v])
change [a v] by (1)
set [b v] to ()
repeat (length of (item (a) of [list v]))
set [b v] to (join (b) (join [/] (letter (((length of (b)) / (2)) + (1)) of (item (a) of [list v]))))
end
set [output v] to (join (output) (join (b) [,]))
end
</pre>

<h2> Savecode Usage </h2>

<p> This code may be used to create a savecode. Script 1 or 2 is recommended.</p>

<p> The following script will save the variables <i>foo</i>, <i>bar</i>, and <i>baz</i>. </p>

<pre class="blocks">
define create savecode
delete all of [list v]
add (foo) to [list v]
add (bar) to [list v]
add (baz) to [list v]
list to string :: custom
</pre>

<p> To save lists, each list must be converted into a string independently and saved with the same method as above. </p>

<p> The following script will save the lists <i>foo</i>, <i>bar</i>, and <i>baz</i>

<pre class="blocks">
define create savecode
delete all of [list v]
delete all of [savelists v]
set [i v] to (0)
repeat (length of [foo v])
change [i v] by (1)
add (item (i) of [foo v]) to [list v]
end
list to string :: custom
add (output) to [savelists v]
delete all of [list v]
set [i v] to (0)
repeat (length of [bar v])
change [i v] by (1)
add (item (i) of [bar v]) to [list v]
end
list to string :: custom
add (output) to [savelists v]
delete all of [list v]
set [i v] to (0)
repeat (length of [baz v])
change [i v] by (1)
add (item (i) of [baz v]) to [list v]
end
list to string :: custom
add (output) to [savelists v]
delete all of [list v]
set [i v] to (0)
repeat (length of [savelists v])
change [i v] by (1)
add (item (i) of [savelists v]) to [list v]
end
list to string :: custom
</pre>

<h1> String to List </h1>

<p> The following scripts decode the modified CSV format. </p>

<h2> Scripts </h2>

<p> Scripts 1 through 3 work in a similar manner. Each script goes through each character of the string. Let "appendItem" refer to the string that will be added to the output list. If the character is a comma, appendItem is added to the output list. If the character is a slash, the next character is appended to appendItem. If none of the conditions are true, the current character is added to appendItem. Eventually the program will encounter the end of the string, where it terminates. </p>

<p> All scripts support decoding strings where every character is escaped (generated by Script 3 in previous section). </p>

<h3> Script 1 (3rd fastest) </h3>

<pre class="blocks">
define string to list (str)
delete all of [list v]
set [a v] to (1)
set [b v] to ()
repeat until <(a) > (length of (str))>
if <(letter (a) of (str)) = [,]> then
add (b) to [list v]
set [b v] to ()
else
if <(letter (a) of (str)) = [/]> then
change [a v] by (1)
end
set [b v] to (join (b) (letter (a) of (str)))
end
change [a v] by (1)
end
</pre>

<h3> Script 2 (2rd fastest) </h3>

<pre class="blocks">
define string to list (str)
delete all of [list v]
set [a v] to (1)
set [b v] to ()
repeat until <(a) > (length of (str))>
if <(letter (a) of (str)) = [,]> then
add (b) to [list v]
set [b v] to ()
else
change [a v] by <(letter (a) of (str)) = [/]>
set [b v] to (join (b) (letter (a) of (str)))
end
change [a v] by (1)
end
</pre>

<h3> Script 3 (4rd fastest) </h3>

<pre class="blocks">
define string to list (str)
delete all of [list v]
set [a v] to (1)
set [b v] to ()
repeat until <(a) > (length of (str))>
if <(letter (a) of (str)) = [,]> then
add (b) to [list v]
set [b v] to ()
else
set [b v] to (join (b) (letter ((a) + <(letter (a) of (str)) = [/]>) of (str)))
end
change [a v] by ((1) + <(letter (a) of (str)) = [/]>)
end
</pre>

<h3> Script 4 (fastest) </h3>

<pre class="blocks">
define string to list (str)
delete all of [list v]
set [a v] to (1)
repeat until <(a) > (length of (str))>
set [b v] to ()
repeat until <(letter (a) of (str)) = [,]>
set [b v] to (join (b) (letter ((a) + (1)) of (str)))
change [a v] by (2)
end
add (b) to [list v]
change [a v] by (1)
end
</pre>

<h4> Important Note </h4>

<p> This code nearly runs twice as fast as the previous scripts, however, the code must have every character escaped. Script 3 in the previous section provides these string outputs. </p>

<h2> Savecode Usage </h2>

<p> This code may be used to decode a savecode. Script 2 is recommended. </p>

<p> The following script will set <i>foo</i>, <i>bar</i>, and <i>baz</i> to the values specified in the savecode.</p>

<pre class="blocks">
define decode savecode (savecode)
string to list (savecode) :: custom
set [foo v] to (item (1) of [list v])
set [bar v] to (item (2) of [list v])
set [baz v] to (item (3) of [list v])
</pre>

<p> Similarly, if there are lists, they all can be decoded separately. The script below will set lists <i>foo</i>, <i>bar</i>, and <i>baz</i> to the values specified in the savecode. </p>

<pre class="blocks">
define decode savecode (savecode)
string to list (savecode) :: custom
set [i v] to (0)
delete all of [savelists v]
repeat (length of [list v])
change [i v] by (1)
add (item (i) of [list v]) to [savelists v]
end
string to list (item (1) of [savelists v]) :: custom
set [i v] to (0)
delete all of [foo v]
repeat (length of [list v])
change [i v] by (1)
add (item (i) of [list v]) to [foo v]
end
string to list (item (2) of [savelists v]) :: custom
set [i v] to (0)
delete all of [bar v]
repeat (length of [list v])
change [i v] by (1)
add (item (i) of [list v]) to [bar v]
end
string to list (item (3) of [savelists v]) :: custom
set [i v] to (0)
delete all of [baz v]
repeat (length of [list v])
change [i v] by (1)
add (item (i) of [list v]) to [baz v]
end
</pre>